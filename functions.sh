#!/bin/bash

export MOS_ROOT=$(dirname $0)
export SRC_ROOT="src"

# ----------------------------------------------------------------------------
# __compile
# Compiles files and generates object and list files. The hierarchy of the
# source file is recreated at 'OBJ_PATH', for the object and list files. These
# files thus have the same hierarchical path as the source files, but differnt
# root directory.
#
# Object and list files has the same file title, just with .o extension,
# instead of .c of the input source files.
#
# $1   - Compiler/Assembler program with arguments
# $2   - Function to do the compilation.
#        Signature: `func (translator, input_file, obj_file, list_file)
# $3   - Path to the directory for obj and list files.
#        Relative to MOS_ROOT_PATH dir.
# ...  - Source flies to compile. Relative to SRC_ROOT dir.
__compile()
{
    local TRANSLATOR=$1            ; shift
    local CFUNC=$1                 ; shift
    local OBJ_PATH=$1              ; shift
    local SRC_FILES="$@"

    for fn in ${SRC_FILES[@]}; do
        local INFILE=$SRC_ROOT/$fn

        local SRC_FNAME=${fn##*/}        # Remove path. Keep filetitle and ext.
        local SRC_FTILE=${SRC_FNAME%.*}  # Remove extension.

        local SRC_RELPATH=${fn%/*.*}     # Remove filename. Keep Relative path.
        if [ $SRC_RELPATH == $fn ]; then
            local SRC_RELPATH=""
        fi

        local OUTPATH=$OBJ_PATH/$SRC_RELPATH
        local OBJFILE=$OUTPATH/$SRC_FTILE.o
        local LISTFILE=$OUTPATH/$SRC_FTILE.lst

        local T_FILENAME=${TRANSLATOR%%\ *}      # Get executable file name
        echo -e "\t$T_FILENAME: $INFILE"

        mkdir -p $OUTPATH                                               || exit
        $CFUNC "$TRANSLATOR" "$INFILE" "$OBJFILE" "$LISTFILE"           || exit
    done
}

# ----------------------------------------------------------------------------
# __compile_cc
# To be passed to the __compile function. Called from __compile function, with
# the intension to compile a C file and produce a object and list file.
#
# $1   - Compiler/Assembler program with arguments
# $2    - Input C filename
# $3    - Object file name, which needs to be generated by this file.
# $4    - Listings file name, which needs to be generated by this file.
__compile_cc()
{
    local CC=$1
    local IN_FILE=$2
    local OBJ_FILE=$3
    local LIST_FILE=$4

    # Because the same files are compiled twice, (once for the list files and
    # another time the actual object files are created), any warning will
    # appear twice. To prevent this, all output is purged when generating the
    # list files.
    # However, this means errors will also not be shown. To remedy this, the
    # 2nd compilation step will always occur. Not the ideal solution, I know.
    $CC -S "$IN_FILE" -o "$LIST_FILE" > /dev/null 2>&1
    $CC -c "$IN_FILE" -o "$OBJ_FILE"                                    || exit
}

# ----------------------------------------------------------------------------
# __compile_nasm
# To be passed to the __compile function. Called from __compile function, with
# the intension to compile a nasm assembly file and produce a object and list
# file.
#
# $1    - Compiler/Assembler program with arguments
# $2    - Input C filename
# $3    - Object file name, which needs to be generated by this file.
# $4    - Listings file name, which needs to be generated by this file.
__compile_nasm()
{
    local ASM=$1
    local IN_FILE=$2
    local OBJ_FILE=$3
    local LIST_FILE=$4

    $ASM "$IN_FILE" -l "$LIST_FILE" -o "$OBJ_FILE"                       || exit
}

# ----------------------------------------------------------------------------
# compile_cc
# Compiles C files and generates object and list files. The hierarchy of the
# source file is recreated at 'OBJ_PATH', for the object and list files. These
# files thus have the same hierarchical path as the source files, but differnt
# root directory.
#
# Object and list files has the same file title, just with .o extension,
# instead of .c of the input source files.
#
# $1   - C compiler and argumnets.
# $2   - Path to the directory for obj and list files.
#        Relative to MOS_ROOT_PATH dir.
# ...  - Source flies to compile. Relative to SRC_ROOT dir.
compile_cc()
{
    local CC=$1               ; shift
    local OBJ_PATH=$1         ; shift
    local SRC_FILES="$@"

    __compile "$CC" "__compile_cc" "$OBJ_PATH" "$SRC_FILES"
}

# ----------------------------------------------------------------------------
# compile_nasm
# Compiles nasm assembly files and generates object and list files.
# The hierarchy of the source file is recreated at 'OBJ_PATH', for the object
# and list files. These files thus have the same hierarchical path as the
# source files, but differnt root directory.
#
# Object and list files has the same file title, just with .o extension,
# instead of .asm or .s of the input source files.
#
# $1   - Nasm assembler and argumnets.
# $2   - Path to the directory for obj and list files.
#        Relative to MOS_ROOT_PATH dir.
# ...  - Source flies to compile. Relative to SRC_ROOT dir.
compile_nasm()
{
    local ASM=$1              ; shift
    local OBJ_PATH=$1         ; shift
    local SRC_FILES="$@"

    __compile "$ASM" "__compile_nasm" "$OBJ_PATH" "$SRC_FILES"
}

# ----------------------------------------------------------------------------
# link_unittest_add_file
# Adds C files, whose corresponding object files need to be linked.
#
# $1   - Path to the directory for obj and list files.
#        Relative to MOS_ROOT_PATH dir.
# $2   - Flies to compile. Relative to SRC_ROOT dir.
link_unittest_add_file()
{
    local OBJ_PATH=$1
    local FILES=$2

    for fn in ${FILES[@]}; do
        local SRC_FTILE=${fn%.*}              # Remove extension.
        local OBJ_FILE=$OBJ_PATH/$SRC_FTILE.o # Path to object file
        GLOBAL_MOS_BUILD_OBJ_FILES=("${GLOBAL_MOS_BUILD_OBJ_FILES[@]}" "$OBJ_FILE")
    done
}

# ----------------------------------------------------------------------------
# link_unittest
# Calls the Linker program with the appropriate arguments. This links all the
# previously added object files (using link_unittest_add_file) into an
# executable. Later it also clears the global object file list.
# $1   - Linker argumnets.
# $2   - Test executable filename
link_unittest()
{
    local LD=$1
    local EXE_PATH=$2

    $LD "${GLOBAL_MOS_BUILD_OBJ_FILES[@]}" -o "$EXE_PATH"
    GLOBAL_MOS_BUILD_OBJ_FILES=()       # Clear the array.
}
